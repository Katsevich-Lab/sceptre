---
title: "Get started with sceptre"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get started with sceptre}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The objective of `sceptre` is to power statistically rigorous, computationally efficient, and user-friendly single-cell CRISPR screen data analysis. The standard pipeline involved in applying `sceptre` to analyze a dataset consists of several steps, which we summarize in the following schematic.

```{r, out.width = "600px", fig.align="center", echo = FALSE, fig.cap=c("Standard `sceptre` pipeline")}
knitr::include_graphics("pipeline_schematic.png")
```

This vignette illustrates application of `sceptre` to a CRISPRi screen of candidate enhancers in K562 cells. The goal of the analysis is to confidently link enhancers to genes by testing for changes in gene expression in response to the CRISPR perturbations of the candidate enhancers. We begin by loading the `sceptre` package.

```{r setup}
library(sceptre)
```

```{r, echo = FALSE}
library(Matrix)
```

## The whole game

Using `sceptre` is simple. Below, we provide a minimal working example of applying `sceptre` to analyze the example data. First, we load the example data into R via the function `import_data_from_cellranger()`, thereby creating a `sceptre_object`, which is an object-based representation of the single-cell CRISPR screen data. Next, we specify the gRNA-gene pairs that we seek to test for association. Then, we call the pipeline functions on the `sceptre_object` in order. Finally, we write the outputs to the directory `~/sceptre_outputs`.

```{r, eval=FALSE}
# load the data, creating a sceptre_object
directories <- paste0(system.file("extdata", package = "sceptre"),
                      "/highmoi_example/gem_group_", 1:2)
data(grna_target_data_frame_highmoi)
sceptre_object <- import_data_from_cellranger(directories = directories,
moi = "high",
grna_target_data_frame = grna_target_data_frame_highmoi)

# construct the grna-gene pairs to analyze
positive_control_pairs <- construct_positive_control_pairs(sceptre_object)
discovery_pairs <- construct_cis_pairs(sceptre_object, positive_control_pairs)

# apply the pipeline functions to the sceptre_object in order
sceptre_object <- sceptre_object |>
  set_analysis_parameters(discovery_pairs, positive_control_pairs) |>
  run_calibration_check() |>
  run_power_check() |>
  run_discovery_analysis()

# write the results to disk
write_outputs_to_directory(sceptre_object, "~/sceptre_outputs")
```

That's it. Note that `|>` is the base R pipe operator, equivalent in this context to the more familiar `%>%`. We describe each step of the pipeline in greater detail below.

## I. Import data

The first step is to import the data. The simplest way to import the data is to read the output of one or more calls to `cellranger_count()` into `sceptre` via the function `import_data_from_cellranger()`. `import_data_from_cellranger()` requires three arguments: `directories`, `grna_target_data_frame`, and `moi`.

1.  `directories` is a character vector specifying the locations of the directories outputted by one or more calls to `cellranger_count()`. Below, we set the variable `directories` to the (machine-dependent) location of the example CRISPRi data on disk.

    ```{r}
    directories <- paste0(system.file("extdata", package = "sceptre"), "/highmoi_example/gem_group_", 1:2)
    directories # file paths to the example data on your computer
    ```

    `directories` points to two directories, both of which store the expression data in matrix market format, containing the files `barcodes.tsv.gz`, `features.tsv.gz`, and `matrix.mtx.gz`.

    ```{r}
    list.files(directories[1])
    list.files(directories[2])
    ```

2.  `grna_target_data_frame` is a data frame mapping each individual gRNA to the genomic element that the gRNA targets. `grna_target_data_frame` contains two required columns: `grna_id` and `grna_target`. `grna_id` is the ID of an individual gRNA, while `grna_target` is a label specifying the genomic element that the gRNA targets. (Typically, multiple gRNAs are designed to target a given genomic element in a single-cell CRISPR screen.) Non-targeting gRNAs are assigned a gRNA target label of "non-targeting". `grna_target_data_frame` optionally can contain the columns `chr`, `start`, and `end`, which give the chromosome, start coordinate, and end coordinate, respectively, of the genomic region that each gRNA targets. We load and examine the `grna_target_data_frame` corresponding to the example data.

    ```{r}
    data(grna_target_data_frame_highmoi)
    grna_target_data_frame_highmoi[c(1:4, 21:24, 80:83),]
    ```

    Some gRNAs (e.g., `grna_CCGGGCG` and `grna_TGGCGGC`) target gene transcription start sites and serve as positive controls; other gRNAs (e.g., `grna_TCTTGAC` and `grna_TGATCGC`) target candidate enhancers, while others still (e.g., `grna_TATTCGT` and `grna_GACCTCC`) are non-targeting. Each gene and candidate enhancer in this dataset is targeted by exactly two gRNAs.

3.  `moi` is a string specifying the multiplicity-of-infection (MOI) of the data, taking values "high" or "low". A high-MOI (respectively, low-MOI) dataset is one in which the experimenter has aimed to insert multiple gRNAs (respectively, a single gRNA) into each cell. (If a given cell is determined to contain multiple gRNAs in a low-MOI screen, that cell is removed as part of the quality control step, as discussed below.) The example dataset is a high MOI dataset, and so we set `moi` to "high".

    ```{r}
    moi <- "high"
    ```

Finally, we call the function `import_data_from_cellranger()`, passing `directories`, `grna_target_data_frame`, and `moi` as arguments.

```{r}
sceptre_object <- import_data_from_cellranger(directories = directories,
                                              grna_target_data_frame = grna_target_data_frame_highmoi,
                                              moi = moi)
```

`import_data_from_cellranger()` returns a `sceptre_object`, which is an object-based representation of the single-cell CRISPR screen data. Evaluating `sceptre_object` in the console prints a helpful summary of the data.

```{r}
sceptre_object
```

Several metrics are displayed, including the number of cells, the number of genes (or "responses"), and the number of gRNAs present in the data. `sceptre` also automatically computes the following cell-specific covariates: `grna_n_nonzero` (i.e., the number of gRNAs expressed in the cell), `grna_n_umis` (i.e., the number of gRNA UMIs sequenced in the cell), `response_n_nonzero` (i.e., the number of responses expressed in the cell), `response_n_umis` (i.e., the number of response UMIs sequenced in the cell), `response_p_mito` (i.e., the fraction of transcripts mapping to mitochondrial genes), and `batch`. (Cells loaded from different directories are assumed to come from different batches.)

## II. Set analysis parameters

The second step is to set the analysis parameters, which are the parameters that govern how the statistical analysis is to be carried out. The most important analysis parameters are the discovery pairs, positive control pairs, sidedness, and gRNA grouping strategy.

1.  **Discovery pairs and positive control pairs**. The primary goal of `sceptre` is to determine whether perturbation of a gRNA target (such as an enhancer) leads to a change in expression of a response (such as gene). We use the term *target-response pair* to refer to a given gRNA target and response that we seek to test for association (upon perturbation of the gRNA target). A *discovery target-response pair* is a target-response pair whose association status we do not know but would like to learn. For example, in an experiment in which we aim to link putative enhancers to genes, the discovery target-response pairs might consist of the set of putative enhancers and genes in close physical proximity to one another.

    A *positive control target-response pair* is a target-response pair for which we know (or have strong reason to believe) that there *is* a relationship between the target and the response. Positive control target-response pairs often are formed by coupling a transcription start site to the gene known to be regulated by that transcription start site. Finally, a *negative control target-response pair* is a target-response pair for which we know (or have strong reason to believe) that there is *not* a relationship between the target and the response. We defer a detailed discussion of negative control pairs to a subsequent section of this vignette. Discovery pairs are of primary scientific interest, while negative control and positive control pairs help us verify that the biological assay and statistical methodology are in working order.

    `sceptre` offers several helper functions to facilitate the construction of positive control and discovery pairs. The function `construct_positive_control_pairs()` takes as argument a `sceptre_object` and outputs the set of positive control pairs, where the positive control pairs are formed by matching gRNA targets (as contained in the `grna_target_data_frame`) to response IDs. Positive control pairs are optional and need not be computed.

    ```{r}
    positive_control_pairs <- construct_positive_control_pairs(sceptre_object = sceptre_object)
    head(positive_control_pairs)
    ```

    Next, the functions `construct_cis_pairs()` and `construct_trans_pairs()` facilitate the construction of *cis* and *trans* discovery sets, respectively. `construct_cis_pairs()` takes as arguments a `sceptre_object` and an integer `distance_threshold` and returns the set of response-target pairs located on the same chromosome within `distance_threshold` bases of one another. `positive_control_pairs` optionally can be passed, in which case the positive control gRNA targets are excluded from the *cis* pairs.

    ```{r}
    discovery_pairs <- construct_cis_pairs(sceptre_object = sceptre_object,
                                           positive_control_pairs = positive_control_pairs,
                                           distance_threshold = 5e6)
    discovery_pairs[c(1:4, 101:104),]
    ```

    See the help pages of the pair constructor helpers (`?construct_positive_control_pairs()`, `?construct_cis_pairs()`, `?construct_trans_pairs()`) for more information about these functions.

2.  **Sidedness**. The parameter `side` controls whether to run a left-tailed (`"left"`), right-tailed (`"right"`), or two-tailed (`"both"`; default) test. A left-tailed (resp., right-tailed) test is appropriate when testing for a decrease (resp., increase) in expression; a two-tailed test, by contrast, is appropriate when testing for an increase *or* decrease in expression. A left-tailed test is the most appropriate choice for a CRISPRi screen of enhancers, and so we set `side` to `"left"`.

    ```{r}
    side <- "left"
    ```

3.  **gRNA grouping strategy**. Typically, multiple gRNAs are designed to target a given genomic element. The parameter `grna_grouping_strategy` controls if and how gRNAs that target the same genomic element are grouped. The default option, `"union"`, combines gRNAs that target the same element into a single "grouped gRNA;" this "grouped gRNA" is tested for association against the responses to which the element is paired. `grna_grouping_strategy` also can be set to "singleton," in which case each gRNA targeting a given element is tested individually against the responses paired to that element. In our analysis of the example data, we use the default "union" strategy.

Finally, we set the analysis parameters by calling the function `set_analysis_parameters()`, passing `sceptre_object`, `discovery_pairs`, `positive_control_pairs`, and `side` as arguments. Note that `sceptre_object` and `discovery_pairs` are the only required arguments.

```{r, message=FALSE}
sceptre_object <- set_analysis_parameters(sceptre_object = sceptre_object,
                                          discovery_pairs = discovery_pairs,
                                          positive_control_pairs = positive_control_pairs,
                                          side = side)
```

We call `print()` on the resulting `sceptre_object`, which prints a detailed summary of the analysis status (output not displayed here).

```{r,results='hide'}
print(sceptre_object)
```

## III. Assign gRNAs to cells (optional)

The third step is to assign gRNAs to cells. This step can be skipped, in which case gRNAs are assigned to cells automatically using default options. We begin by plotting the UMI count distribution of several randomly selected gRNAs, which we do by calling the function `plot_grna_count_distributions()`.

```{r, eval=FALSE}
plot_grna_count_distributions(sceptre_object)
```

```{r, out.width = "550px", fig.align="center", echo = FALSE, fig.cap=c("Histograms of the gRNA count distributions")}
set.seed(2)
p <- plot_grna_count_distributions(sceptre_object = sceptre_object)
ggplot2::ggsave(filename = "grna_count_distribution.png", plot = p, device = "png", scale = 1.1, width = 5, height = 4, dpi = 330)
knitr::include_graphics("grna_count_distribution.png")
```

The gRNAs in this dataset display fairly bimodal count distributions. Consider, for example, `gRNA_ATTAGCA` (bottom left corner). Many cells exhibits a UMI count of $\leq 1$ or $\geq 5$ for this gRNA, while only a handful of cells exhibits a UMI count of 2, 3, or 4. The vast majority of cells with a UMI count of 1 likely do not actually contain `gRNA_ATTAGCA`. This is an example of "background contamination," the phenomenon by which gRNA transcripts sometimes map to cells that do not contain the corresponding gRNA.

`sceptre` provides three methods for assigning gRNAs to cells, all of which account for the background contamination issue. The default method for high-MOI data is a mixture-model based approach. The gRNA counts are regressed onto the (unobserved) gRNA presence/absence indicator and the cell-specific covariates (e.g., `grna_n_umis`, `batch`) via a latent variable Poisson GLM. The fitted model yields the probability that each cell contains the gRNA, and these probabilities are thresholded to assign the gRNA to cells. The default method in low-MOI is the simpler "maximum" approach: the gRNA that produced the greatest number of UMIs in a given cell is assigned to that cell. A backup option in both low- and high-MOI is the "thresholding" approach: a given gRNA is assigned to a given cell if the UMI count of that gRNA within that cell exceeds some integer threshold.

We carry out the gRNA-to-cell assignments by calling the function `assign_grnas()`. `assign_grnas()` takes two main arguments: `sceptre_object` (required) and `method` (optional); the latter can be set to `"mixture"`, `"maximum"`, or `"thresholding"`. In this example we use the default high-MOI assignment method of `"mixture"`. We also parallelize execution of the function by setting `parallel` to `TRUE`. (Windows users should set `parallel` to `FALSE`, as parallel execution is not yet configured for Windows.)

```{r,results='hide'}
sceptre_object <- assign_grnas(sceptre_object = sceptre_object,
                               parallel = TRUE)
```

We can call `plot()` on the resulting

```{r,eval=FALSE}
plot(sceptre_object)
```

```{r, out.width = "550px", fig.align="center", echo = FALSE, fig.cap=c("gRNA-to-cell assignments")}
p <- plot(sceptre_object)
ggplot2::ggsave(filename = "grna_count_assignments.png", plot = p, device = "png", scale = 1.1, width = 5, height = 4, dpi = 330)
knitr::include_graphics("grna_count_assignments.png")
```

## IV. Run quality control (optional)

The fourth step is to run quality control. This step likewise can be skipped, in which case quality control automatically is run with default arguments.
